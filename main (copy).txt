/*To realize aquisition of data in MATLAB from IMS & display it */

#include "mbed.h"
#include "XNucleoIKS01A2.h"
#include <stdio.h>
#include <string.h>


#define MSGSIZE 150

void Rx_interrupt();

DigitalOut rst(D7);//reset pin
DigitalOut wkp(D13);//wake up to wake from sleep mode
DigitalIn pps(D6);//internal timer pulse per second blinking red light on the board
Serial gnss(PA_9,PA_10,230400);
Serial pc(USBTX,USBRX,921600);

Timer tim;//SAMPLING PERIOD
Timer tim2;// time for all the aquisition

union MYINT16 {
    int16_t data;
    uint8_t byte[2];
} app;

union MYFLOAT {
    float time;
    uint8_t byte[2];
} stamp;

static XNucleoIKS01A2 *mems_expansion_board = XNucleoIKS01A2::instance(D14,D15,D4,D5);
static LSM6DSLSensor *acc_gyro = mems_expansion_board->acc_gyro;

 

int16_t xRaw[3],gRaw[3];
float sX,sG; //sensetivity for gyro and acc

 

DigitalIn btn(USER_BUTTON);//blue button//
DigitalOut led(LED1);//LED//

 

char carat;
char buffer[MSGSIZE];
char bufferRX[MSGSIZE];
char msg[] = "$PSTMPV";

 

uint8_t i,length;
int8_t res;

 

bool firstTime = true;
bool rcvdMsg = false;
uint8_t cnt = 0, cntRX;

 

int main()
{
    acc_gyro->enable_x();
    acc_gyro->enable_g();

 

    rst.write(1);

 

    //acc_gyro->get_x_sensitivity(&sX);
    //acc_gyro->get_x_sensitivity(&sX);

 

    while (pc.getc()!='k');
    tim.start();
    tim2.start();

 

    while(!pps);  //so we start at a rising time of pps
    while(pps);
    while(!pps);
    tim2.reset();
    gnss.attach(&Rx_interrupt, Serial::RxIrq);
    // when serial reciever inteerept occurs it stops the main program//

 

    while(1) {
        tim.reset();
        acc_gyro->get_x_axes_raw(xRaw);
        acc_gyro->get_g_axes_raw(gRaw);
        stamp.time = tim2.read();
        pc.putc('T');// time for matlab to understand what it is

 

        for(int k=0; k<4; k++) {
            pc.putc(stamp.byte[k]);
        }

 

        pc.putc('A');

 

        for(int k=0; k<3; k++) {
            app.data = xRaw[k];
            pc.putc(app.byte[0]);
            pc.putc(app.byte[1]);
        }

 

        pc.putc('W');

 

        for(int k=0; k<3; k++) {
            app.data = gRaw[k];
            pc.putc(app.byte[0]);
            pc.putc(app.byte[1]);
        }

 

        if(rcvdMsg) {
            for(int i = 0; i<cntRX; i++) {
                pc.putc(bufferRX[i]);
            }
            rcvdMsg = false;
        }
        double time = tim.read();
        if(time<0.01) {                     
            wait(0.01-time);
        }
    }
    return 0;
}

 

void Rx_interrupt()
{
    led = 1;
    if (firstTime) {
        memset(buffer,0,MSGSIZE);
        firstTime = false;
    }
    carat = gnss.getc();
    if(carat!=10) {
        buffer[cnt++] = carat;
    } else {
        buffer[cnt++] = carat;
        res = memcmp(buffer,msg,sizeof(msg));
    }
    if(res==1) {
        rcvdMsg = true;
        memcpy(bufferRX, buffer, cnt+1);
        cntRX = cnt+1;
        cnt = 0;
        res = 0;
    }
    led = 0;
    return;
}
